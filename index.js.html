<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const needle = require("needle");

const Bucket = require("./util/Bucket");
const constants = require("./constants");

/**
 * The bigol thing
 */
class Mika {
    constructor() {
        this.bucket = new Bucket();
        this.baseURL = constants.BaseURL;
    }

    _queryString(options) {
        let args = [];
        for (let p in options) {
            if (options.hasOwnProperty(p)) {
                if (Array.isArray(options[p])) {
                    for (let index of options[p]) {
                        args.push(`${encodeURIComponent(p)}=${encodeURIComponent(index)}`);
                    }
                } else {
                    args.push(`${encodeURIComponent(p)}=${encodeURIComponent(options[p])}`);
                }
            }
        }
        return `?${args.join("&amp;")}`;
    }

    _percentEncode(sql) {
        return sql; // TODO
    }

    _requestHandler(method, url, options, attempts = 0, topResolve, topReject) {
        if (attempts == 0) url = this.baseURL + url;
        if (options) url += this._queryString(options);
        return new Promise((resolve, reject) => {
            this.bucket.enqueue(function() {
                needle.request(method, url, null, (err, response, body) => {
                    if (!err &amp;&amp; response.statusCode == 200) {
                        topResolve ? topResolve(body) : resolve(body);
                    } else if (err) {
                        reject(err);
                    } else {
                        if (response.statusCode == 500) {
                            reject({
                                "code": response.statusCode,
                                "error": body.error
                            });
                        } else {
                            if (attempts > 2) {
                                reject({
                                    "code": -1,
                                    "error": "Too many attempts, timing out"
                                });
                            } else {
                                this._requestHandler(method, url, null, attempts + 1, resolve, reject);
                            }
                        }
                    }
                });
            });
        });
    }

    /**
     * Returns match data for a specified match id.
     * @param {number} matchID - Which match to request
     */
    getMatch(matchID) {
        return this._requestHandler("GET", `/matches/${matchID}`);
    }

    /**
     * Returns player data for a specified account id
     * @param {number} accountID - Which account to request
     */
    getPlayer(accountID) {
        return this._requestHandler("GET", `/players/${accountID}`);
    }
    
    /**
     * Returns win/loss counts for a specified account id
     * @param {number} accountID - Which account to request
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerWL(accountID, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/wl${options || ""}`);
    }
    
    /**
     * Returns matches played for a specified account id
     * @param {number} accountID - Which account to request
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerMatches(accountID, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/matches${options || ""}`);
    }

    /**
     * Returns heroes played for a specified account id
     * @param {number} accountID - Which account to request
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerHeroes(accountID, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/getPlayerHeroes${options || ""}`);
    }

    /**
     * Returns players played with for a specified account id
     * @param {number} accountID - Which account to request
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerPeers(accountID, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/peers${options || ""}`);
    }

    /**
     * Returns pro players played with for a specified account id
     * @param {number} accountID - Which account to request
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerPros(accountID, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/pros${options || ""}`);
    }

    /**
     * Returns truncated player match data for each record for a specified account id
     * @param {number} accountID - Which account to request
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerRecords(accountID, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/records${options || ""}`);
    }

    /**
     * Returns categorical counts for a specified account id
     * @param {number} accountID - Which account to request
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerCounts(accountID, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/counts${options || ""}`);
    }

    /**
     * Returns histogram data for a specified account id
     * @param {number} accountID - Which account to request
     * @param {string} field - Which field to aggregate on
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerHistograms(accountID, field, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/histograms/${field}${options || ""}`);
    }

    /**
     * Returns ward map data for observers and sentries for a specified account id
     * @param {number} accountID - Which account to request
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerWardmap(accountID, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/wardmap${options || ""}`);
    }

    /**
     * Returns words said and read for a specified account id
     * @param {number} accountID - Which account to request
     * @param {object} [options] - Query paramaters for the request
     * @param {number} options.limit - Number of matches to limit to
     * @param {number} options.offset - Number of matches to offset start by
     * @param {number} options.win - Whether the player won
     * @param {number} options.patch - Patch ID
     * @param {number} options.game_mode - Game Mode ID
     * @param {number} options.lobby_type - Lobby type ID
     * @param {number} options.region - Region ID
     * @param {number} options.date - Days previous
     * @param {number} options.lane_role - Lane Role ID
     * @param {number} options.hero_id - Hero ID
     * @param {number} options.is_radiant - Whether the player was radiant (1 for yes, 0 for no)
     * @param {number[]} options.included_account_id - Account IDs in the match
     * @param {number[]} options.excluded_account_id - Account IDs not in the match
     * @param {number[]} options.with_hero_id - Hero IDs on the player's team
     * @param {number[]} options.against_hero_id - Hero IDs against the player's team
     * @param {number} options.significant - Whether the match was significant for aggregation purposes (1 for yes, 0 for no)
     * @param {string} options.sort - The field to return matches sorted by in descending order
     */
    getPlayerWordcloud(accountID, options) {
        if (options) options = this._queryString(options);
        return this._requestHandler("GET", `/players/${accountID}/wordcloud${options || ""}`);
    }

    /**
     * Returns an array of rating history for a specified account id on solo and party MMR
     * @param {number} accountID - Which account to request
     */
    getPlayerRatings(accountID) {
        return this._requestHandler("GET", `/players/${accountID}/ratings`);
    }

    /**
     * Returns an array of hero rankings for a specified account id
     * @param {number} accountID - Which account to request
     */
    getPlayerRankings(accountID) {
        return this._requestHandler("GET", `/players/${accountID}/rankings`);
    }

    /**
     * Queues a refresh for player match history.
     * @param {number} accountID - Which account to refresh
     */
    postPlayerRefresh(accountID) {
        return this._requestHandler("POST", `/players/${accountID}/refresh`);
    }

    /**
     * Returns an array of pro players
     */
    getProPlayers() {
        return this._requestHandler("GET", `/proPlayers`);
    }

    /**
     * Returns an array of pro matches
     */
    getProMatches() {
        return this._requestHandler("GET", `/proMatches`);
    }

    /**
     * Returns an array of truncated public matches
     * @param {boolean} ascending - Whether or not to order by lowest MMR
     */
    getPublicMatches(ascending) {
        return this._requestHandler("GET", `/publicMatches${ascending ? "?mmr_ascending=1" : ""}`);
    }

    /**
     * Returns an array of hero stats in recent matches
     */
    getHeroStats() {
        return this._requestHandler("GET", `/heroStats`);
    }

    /**
     * Submit arbitrary SQL queries to the database
     * @param {string} sql - The string sql query to submit - visit https://www.opendota.com/explorer for details
     * @param {boolean} [encoded=false] - Whether or not the supplied string is percent encoded (false to auto encode)
     */
    explorer(sql, encoded) {
        if (!encoded) sql = this._percentEncode(sql); // TODO
        return this._requestHandler("GET", `/explorer?sql=${sql}`);
    }

    /**
     * Returns OpenDota metadata
     */
    getMetadata() {
        return this._requestHandler("GET", `/metadata`);
    }

    /**
     * Returns MMR distributions overall and by country
     */
    getDistributions() {
        return this._requestHandler("GET", `/distributions`);
    }

    /**
     * Returns an array of players searched by player name.
     * @param {string} q - search string
     * @param {number} [similarity=0.51] - minimum similarity threshold, between 0 and 1
     */
    search(q, similarity) {
        return this._requestHandler("GET", `/search?q=${q}${similarity ? "&amp;similarity=" + similarity : ""}`);
    }

    /**
     * Returns rankings for a specified hero
     * @param {number} heroID - Hero ID
     */
    getRankings(heroID) {
        return this._requestHandler("GET", `/rankings?hero_id=${heroID}`);
    }

    /**
     * Returns benchmarks of average stats for a specified hero
     * @param {number} heroID - Hero ID
     */
    getBenchmarks(heroID) {
        return this._requestHandler("GET", `/benchmarks?hero_id=${heroID}`);
    }

    /**
     * Returns service status of OpenDota
     */
    getStatus() {
        return this._requestHandler("GET", `/status`);
    }

    /**
     * Returns health of OpenDota services
     */
    getHealth() {
        return this._requestHandler("GET", `/health`);
    }

    /**
     * Returns status of a parse request
     * @param {number} jobID - Job ID
     */
    getParseStatus(jobID) {
        return this._requestHandler("GET", `/request/${jobID}`);
    }

    /**
     * Request a match to be parsed by OpenDota
     * @param {number} matchID - Match ID
     */
    requestParse(matchID) {
        return this._requestHandler("POST", `/request/${matchID}`);
    }

    /**
     * Returns an array of the current heroes in the game
     */
    getHeroes() {
        return this._requestHandler("GET", `/heroes`);
    }

    /**
     * Returns an array of leagues in the game
     */
    getLeagues() {
        return this._requestHandler("GET", `/leagues`);
    }

    /**
     * Returns an array of teams in the game
     */
    getTeams() {
        return this._requestHandler("GET", `/teams`);
    }

    /**
     * Returns data to construct a replay URL with
     @param {number} matchID - 
     */
    getReplays(matchID) {
        return this._requestHandler("GET", `/replays?match_id=${matchID}`);
    }
}

module.exports = Mika;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Mika.html">Mika</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Mar 13 2017 18:02:02 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
